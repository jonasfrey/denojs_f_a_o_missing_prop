import {f_s_file_autogenerated_comment} from "./f_s_file_autogenerated_comment.module.js";

var s_content = await Deno.readTextFile("./f_a_o_missing_prop.module.js");
// console.log(s_content)
var s_start = 'readme.md:startfile'
var s_end = 'readme.md:endfile'
var n_index_start = s_content.indexOf(s_start);
if(n_index_start == -1){
    console.log(`cannot find string ${s_start}`)
    Deno.exit(-1)
}
var n_index_end = s_content.indexOf(s_end, n_index_start);
var s_section_with_readme_comments = s_content.substring(n_index_start+s_start.length, n_index_end);
// console.log(s_section_with_readme_comments);
// Deno.exit(0)
var a_s_line = s_section_with_readme_comments.split('\n');
let s_comment_start = "//";
var s_content_readme = ``
let s_readme_line_start = "readme.md:"
var a_s_line__content_readme = []
for(let s_line of a_s_line){
    var s_line_trimmed = s_line.trim();
    if(s_line_trimmed.indexOf(s_comment_start) == 0){
        //lines not containing readme.md are ignored
        var n_index = s_line_trimmed.indexOf(s_readme_line_start)
        if(n_index != -1){
            a_s_line__content_readme.push( 
                s_line_trimmed.substring(
                    n_index+s_readme_line_start.length, 
                )
            );
        }
        
    }else{
        a_s_line__content_readme.push(s_line_trimmed);
    }
}

var s_comment_template_markdown_substitute__s_comment = `[comment]: <> (s_comment)`
var s_comment_line = s_comment_template_markdown_substitute__s_comment.replace(
    's_comment',
    f_s_file_autogenerated_comment(import.meta.url.split("/").pop())
);
var s_path_file__readme = "./readme.md"
a_s_line__content_readme = [s_comment_line].concat(a_s_line__content_readme)
var s_content_readme = a_s_line__content_readme.join("\n")
await Deno.writeTextFile(
    s_path_file__readme, 
    s_content_readme
);
console.log(`${s_path_file__readme}: has been written`)